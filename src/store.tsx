import React, { createContext, useContext, useState, useEffect } from 'react';
import { Database, Guild, Member, Costume, Role, User, Character } from './types';
import { supabase, supabaseInsert, supabaseUpdate, supabaseUpsert, toCamel } from './supabase';
import { v4 as uuidv4 } from 'uuid';

const defaultData: Database = {
  guilds: {},
  guildOrder: [],
  members: {},
  characters: {},
  costumes: {},
  users: {
    "creator": { username: "creator", password: "123", role: "creator" },
    "admin": { username: "admin", password: "123", role: "admin" },
    "manager": { username: "manager", password: "123", role: "manager" }
  },
  settings: {
    sitePassword: "bd2",
    redirectUrl: "https://www.browndust2.com/"
  }
};

type ViewState = { type: 'admin' } | { type: 'guild', guildId: string } | null;

interface AppContextType {
  db: Database;
  setDb: React.Dispatch<React.SetStateAction<Database>>;
  currentView: ViewState;
  setCurrentView: React.Dispatch<React.SetStateAction<ViewState>>;
  currentUser: string | null;
  setCurrentUser: React.Dispatch<React.SetStateAction<string | null>>;

  // Member functions
  fetchMembers: (guildId: string, includeNote?: boolean) => void;
  fetchAllMembers: () => Promise<void>;
  addMember: (guildId: string, name: string, role?: Role, note?: string) => Promise<void>;
  updateMember: (memberId: string, data: Partial<Member>) => Promise<void>;
  deleteMember: (memberId: string) => Promise<void>;
  updateMemberCostumeLevel: (memberId: string, costumeId: string, level: number) => Promise<void>;
  updateMemberExclusiveWeapon: (memberId: string, characterId: string, hasWeapon: boolean) => Promise<void>;

  // Guild functions
  addGuild: (name: string) => Promise<void>;
  updateGuild: (guildId: string, data: Partial<Guild>) => Promise<void>;
  deleteGuild: (guildId: string) => Promise<void>;

  // Character functions
  addCharacter: (name: string, order: number) => Promise<void>;
  updateCharacter: (characterId: string, data: Partial<Character>) => Promise<void>;
  deleteCharacter: (characterId: string) => Promise<void>;
  updateCharactersOrder: (newOrder: Character[]) => Promise<void>;

  // Costume functions
  addCostume: (characterId: string, name: string, order: number) => Promise<void>;
  updateCostume: (costumeId: string, data: Partial<Costume>) => Promise<void>;
  deleteCostume: (costumeId: string) => Promise<void>;
  updateCostumesOrder: (newOrder: Costume[]) => Promise<void>;

  // User and settings functions
  updateUserPassword: (username: string, password: string) => Promise<void>;
  updateUserRole: (username: string, role: User['role']) => Promise<void>;
  addUser: (user: User) => Promise<void>;
  deleteUser: (username: string) => Promise<void>;
  updateSettings: (data: Partial<Database['settings']>) => Promise<void>;

  // Data management
  restoreData: (data: Partial<Database>) => Promise<void>;
}

const AppContext = createContext<AppContextType | undefined>(undefined);

export const AppProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [db, setDbState] = useState<Database>(defaultData);
  const [currentView, setCurrentView] = useState<ViewState>(null);
  const [currentUser, setCurrentUserState] = useState<string | null>(() => {
    return sessionStorage.getItem('currentUser');
  });

  const setCurrentUser = (user: string | null) => {
    setCurrentUserState(user);
    if (user) {
      sessionStorage.setItem('currentUser', user);
    } else {
      sessionStorage.removeItem('currentUser');
    }
  };
  const [loadedStates, setLoadedStates] = useState({
    global: false,
    guilds: false,
    costumes: false,
    characters: false,
    users: false
  });

  const isLoaded = loadedStates.global && loadedStates.guilds && loadedStates.costumes && loadedStates.users && loadedStates.characters;

  const [isOffline, setIsOffline] = useState(false);

  // Subscribe to global data (costumes, users) and guilds
  useEffect(() => {
    const fetchInitialData = async () => {
      try {
        const [guildsRes, charactersRes, costumesRes, usersRes, settingsRes] = await Promise.all([
          supabase.from('guilds').select('*'),
          supabase.from('characters').select('*'),
          supabase.from('costumes').select('*'),
          supabase.from('admin_users').select('*'),
          supabase.from('settings').select('*').limit(1).single(),
        ]);

        if (guildsRes.error) throw guildsRes.error;
        if (charactersRes.error) throw charactersRes.error;
        if (costumesRes.error) throw costumesRes.error;
        if (usersRes.error) throw usersRes.error;
        if (settingsRes.error) throw settingsRes.error;

        const guilds = guildsRes.data.reduce((acc, guild) => ({ ...acc, [guild.id]: toCamel(guild) }), {});
        const characters = charactersRes.data.reduce((acc, char) => ({ ...acc, [char.id]: toCamel(char) }), {});
        const costumes = costumesRes.data.reduce((acc, costume) => ({ ...acc, [costume.id]: toCamel(costume) }), {});
        const users = usersRes.data.reduce((acc, user) => ({ ...acc, [user.username]: toCamel(user) }), {});

        setDbState(prev => ({
          ...prev,
          guilds,
          characters,
          costumes,
          users,
          settings: settingsRes.data ? toCamel<Database['settings']>(settingsRes.data) : defaultData.settings,
        }));

        setLoadedStates({ global: true, guilds: true, costumes: true, characters: true, users: true });

      } catch (error) {
        console.error("Error fetching initial data:", error);
        setIsOffline(true);
        setLoadedStates({ global: true, guilds: true, costumes: true, characters: true, users: true });
      }
    };

    fetchInitialData();

    // Supabase real-time subscriptions can be added here if needed

  }, []);

  // Keep track of member subscription
  const [memberUnsub, setMemberUnsub] = useState<(() => void) | null>(null);

  // Function to fetch members for a specific guild
  const fetchMembers = async (guildId: string, includeNote: boolean = false) => {
    if (isOffline) return;

    const selectQuery = includeNote 
      ? '*' 
      : 'id, name, guild_id, role, records, exclusive_weapons, updated_at';

    const { data, error } = await supabase
      .from('members')
      .select(selectQuery)
      .eq('guild_id', guildId);

    if (error) {
      console.error("Error fetching members:", error);
      setIsOffline(true);
      alert("讀取成員列表失敗：權限不足。將切換至離線模式。");
      return;
    }

    const members = data.reduce((acc, member) => ({ ...acc, [member.id]: toCamel(member) }), {});

    setDbState(prev => ({ ...prev, members }));
  };

  const fetchAllMembers = async () => {
    if (isOffline) return;

    const { data, error } = await supabase.from('members').select('*');

    if (error) {
      console.error("Error fetching all members:", error);
      return;
    }

    const allMembers: Record<string, Member> = data.reduce((acc, member) => ({ ...acc, [member.id]: toCamel(member) }), {});
    setDbState(prev => ({ ...prev, members: allMembers }));
  };

  // Cleanup subscription on unmount
  useEffect(() => {
    return () => {
      if (memberUnsub) memberUnsub();
    };
  }, [memberUnsub]);

  // Auto-fetch when entering guild view
  useEffect(() => {
    if (currentView?.type === 'guild' && currentView.guildId) {
      fetchMembers(currentView.guildId);
    } else if (currentView?.type === 'admin') {
      // In admin view, we might not want to clear immediately if we are going to select a guild
      // But for now, let's clear to be safe, or let GuildMembersManager fetch
      setDbState(prev => ({ ...prev, members: {} }));
      if (memberUnsub) {
        memberUnsub();
        setMemberUnsub(null);
      }
    }
  }, [currentView?.type, (currentView as any)?.guildId]);

  // Helper to update local state (deprecated, but kept for compatibility)
  // This function is now primarily for local state updates and might be simplified or removed.
  const setDb = (value: React.SetStateAction<Database>) => {
    setDbState(value);
  };

  const addMember = async (guildId: string, name: string, role: Role = '成員', note: string = '') => {
    const newMember = {
      id: uuidv4(),
      name,
      guildId,
      role,
      note,
      records: {},
      updatedAt: Date.now()
    };

    const { data, error } = await supabaseInsert('members', newMember);

    if (error) {
      console.error('Error adding member:', error);
      return;
    }
    if (data) {
      const addedMember = data[0];
      setDbState(prev => ({
        ...prev,
        members: { ...prev.members, [addedMember.id]: addedMember }
      }));
    }
  };

  const updateMemberCostumeLevel = async (memberId: string, costumeId: string, level: number) => {
    const currentRecords = db.members[memberId]?.records || {};
    const updatedRecords = {
      ...currentRecords,
      [costumeId]: { level }
    };

    const { error } = await supabaseUpdate('members',
      {
        records: updatedRecords,
        updatedAt: Date.now()
      },
      {
        id: memberId
      });

    if (error) {
      console.error('Error updating member costume level:', error);
    } else {
      setDbState(prev => ({
        ...prev,
        members: {
          ...prev.members,
          [memberId]: { ...prev.members[memberId], records: updatedRecords }
        }
      }));
    }
  };

  const updateMember = async (memberId: string, data: Partial<Member>) => {

    const { error } = await supabaseUpdate('members', { ...data, updatedAt: Date.now() }, { id: memberId });

    if (error) {
      console.error('Error updating member:', error);
    } else {
      setDbState(prev => ({
        ...prev,
        members: { ...prev.members, [memberId]: { ...prev.members[memberId], ...data } }
      }));
    }
  };

  const addGuild = async (name: string) => {
    const newGuild = { id: uuidv4(), name, tier: 1, orderNum: 99 };
    const { data, error } = await supabaseInsert('guilds', newGuild);
    if (error) {
      console.error('Error adding guild:', error);
    } else if (data) {
      const addedGuild = data[0];
      setDbState(prev => ({ ...prev, guilds: { ...prev.guilds, [addedGuild.id]: addedGuild } }));
    }
  };

  const updateGuild = async (guildId: string, data: Partial<Guild>) => {
    const { error } = await supabaseUpdate('guilds', data, { id: guildId });
    if (error) {
      console.error('Error updating guild:', error);
    } else {
      setDbState(prev => ({ ...prev, guilds: { ...prev.guilds, [guildId]: { ...prev.guilds[guildId], ...data } } }));
    }
  };

  const deleteGuild = async (guildId: string) => {
    const { error } = await supabase.from('guilds').delete().eq('id', guildId);
    if (error) {
      console.error('Error deleting guild:', error);
    } else {
      setDbState(prev => {
        const { [guildId]: _, ...rest } = prev.guilds;
        return { ...prev, guilds: rest };
      });
    }
  };

  const deleteMember = async (memberId: string) => {
    const { error } = await supabase.from('members').delete().eq('id', memberId);
    if (error) {
      console.error('Error deleting member:', error);
    } else {
      setDbState(prev => {
        const { [memberId]: _, ...rest } = prev.members;
        return { ...prev, members: rest };
      });
    }
  };

  const updateMemberExclusiveWeapon = async (memberId: string, characterId: string, hasWeapon: boolean) => {
    const currentWeapons = db.members[memberId]?.exclusiveWeapons || {};
    const updatedWeapons = {
      ...currentWeapons,
      [characterId]: hasWeapon
    };

    const { error } = await supabaseUpdate('members',
      {
        exclusiveWeapons: updatedWeapons, updatedAt: Date.now()
      },
      {
        id: memberId
      });


    if (error) {
      console.error('Error updating exclusive weapon:', error);
    } else {
      setDbState(prev => ({
        ...prev,
        members: {
          ...prev.members,
          [memberId]: { ...prev.members[memberId], exclusiveWeapons: updatedWeapons }
        }
      }));
    }
  };

  const addCharacter = async (name: string, order: number) => {
    const newChar = { id: uuidv4(), name, orderNum: order };
    const { data, error } = await supabaseInsert('characters', newChar);
    if (error) {
      console.error('Error adding character:', error);
    } else if (data) {
      const addedChar = data[0];
      setDbState(prev => ({
        ...prev,
        characters: { ...prev.characters, [addedChar.id]: addedChar }
      }));
    }
  };

  const updateCharacter = async (characterId: string, data: Partial<Character>) => {
    const { error } = await supabaseUpdate('characters', data, { id: characterId });
    if (error) {
      console.error('Error updating character:', error);
    } else {
      setDbState(prev => ({
        ...prev,
        characters: {
          ...prev.characters,
          [characterId]: { ...prev.characters[characterId], ...data }
        }
      }));
    }
  };

  const deleteCharacter = async (characterId: string) => {
    const { error } = await supabase.from('characters').delete().eq('id', characterId);
    if (error) {
      console.error('Error deleting character:', error);
    } else {
      setDbState(prev => {
        const { [characterId]: _, ...rest } = prev.characters;
        return { ...prev, characters: rest };
      });
    }
  };

  const updateCharactersOrder = async (newOrder: Character[]) => {
    const updates = newOrder.map((char, index) => ({
      id: char.id,
      orderNum: index + 1
    })).filter(u => db.characters[u.id]?.orderNum !== u.orderNum);

    if (updates.length === 0) return;

    // Optimistic update
    setDbState(prev => {
      const newCharacters = { ...prev.characters };
      updates.forEach(u => {
        if (newCharacters[u.id]) {
          newCharacters[u.id] = { ...newCharacters[u.id], orderNum: u.orderNum };
        }
      });
      return { ...prev, characters: newCharacters };
    });

    try {
      await Promise.all(updates.map(u => 
        supabaseUpdate('characters', { orderNum: u.orderNum }, { id: u.id })
      ));
    } catch (error) {
      console.error('Error updating characters order:', error);
      // Revert by fetching fresh data
      const { data, error: fetchError } = await supabase.from('characters').select('*');
      if (!fetchError && data) {
         const characters = data.reduce((acc, char) => ({ ...acc, [char.id]: toCamel(char) }), {});
         setDbState(prev => ({ ...prev, characters }));
      }
    }
  };

  const addCostume = async (characterId: string, name: string, order: number) => {
    const newCostume = { id: uuidv4(), characterId: characterId, name, orderNum: order, isNew: false };
    const { data, error } = await supabaseInsert('costumes', newCostume);
    if (error) {
      console.error('Error adding costume:', error);
    } else if (data) {
      const addedCostume = data[0];
      setDbState(prev => ({
        ...prev,
        costumes: { ...prev.costumes, [addedCostume.id]: addedCostume }
      }));
    }
  };

  const updateCostume = async (costumeId: string, data: Partial<Costume>) => {
    const { error } = await supabaseUpdate('costumes', data, { id: costumeId });
    if (error) {
      console.error('Error updating costume:', error);
    } else {
      setDbState(prev => ({
        ...prev,
        costumes: {
          ...prev.costumes,
          [costumeId]: { ...prev.costumes[costumeId], ...data }
        }
      }));
    }
  };

  const deleteCostume = async (costumeId: string) => {
    const { error } = await supabase.from('costumes').delete().eq('id', costumeId);
    if (error) {
      console.error('Error deleting costume:', error);
    } else {
      setDbState(prev => {
        const { [costumeId]: _, ...rest } = prev.costumes;
        return { ...prev, costumes: rest };
      });
    }
  };

  const updateCostumesOrder = async (newOrder: Costume[]) => {
    const updates = newOrder.map((costume, index) => ({
      id: costume.id,
      orderNum: index + 1
    })).filter(u => db.costumes[u.id]?.orderNum !== u.orderNum);

    if (updates.length === 0) return;

    // Optimistic update
    setDbState(prev => {
      const newCostumes = { ...prev.costumes };
      updates.forEach(u => {
        if (newCostumes[u.id]) {
          newCostumes[u.id] = { ...newCostumes[u.id], orderNum: u.orderNum };
        }
      });
      return { ...prev, costumes: newCostumes };
    });

    try {
      await Promise.all(updates.map(u => 
        supabaseUpdate('costumes', { orderNum: u.orderNum }, { id: u.id })
      ));
    } catch (error) {
      console.error('Error updating costumes order:', error);
      // Revert by fetching fresh data
      const { data, error: fetchError } = await supabase.from('costumes').select('*');
      if (!fetchError && data) {
         const costumes = data.reduce((acc, costume) => ({ ...acc, [costume.id]: toCamel(costume) }), {});
         setDbState(prev => ({ ...prev, costumes }));
      }
    }
  };










  const restoreData = async (data: Partial<Database>) => {
    try {
      if (data.guilds) {
        await supabaseUpsert('guilds', Object.values(data.guilds));
      }
      if (data.characters) {
        await supabaseUpsert('characters', Object.values(data.characters));
      }
      if (data.costumes) {
        await supabaseUpsert('costumes', Object.values(data.costumes));
      }
      if (data.members) {
        await supabaseUpsert('members', Object.values(data.members));
      }
      if (data.users) {
        await supabaseUpsert('admin_users', Object.values(data.users));
      }
      if (data.settings) {
        await supabaseUpsert('settings', data.settings);
      }
      
      alert('資料還原成功！頁面即將重新整理。');
      window.location.reload();
    } catch (error) {
      console.error('Error restoring data:', error);
      throw error;
    }
  };

  const updateUserPassword = async (username: string, password: string) => {
    const { error } = await supabaseUpdate('admin_users', { password }, { username: username });
    if (error) {
      console.error('Error updating user password:', error);
    } else {
      setDbState(prev => ({
        ...prev,
        users: {
          ...prev.users,
          [username]: { ...prev.users[username], password }
        }
      }));
    }
  };

  const updateUserRole = async (username: string, role: User['role']) => {
    const { error } = await supabaseUpdate('admin_users', { role }, { username: username });
    if (error) {
      console.error('Error updating user role:', error);
    } else {
      setDbState(prev => ({
        ...prev,
        users: {
          ...prev.users,
          [username]: { ...prev.users[username], role }
        }
      }));
    }
  };

  const addUser = async (user: User) => {
    const { data, error } = await supabaseInsert('admin_users', user);
    if (error) {
      console.error('Error adding user:', error);
    } else if (data) {
      const addedUser = data[0] as User;
      setDbState(prev => ({
        ...prev,
        users: { ...prev.users, [addedUser.username]: addedUser }
      }));
    }
  };

  const deleteUser = async (username: string) => {
    const { error } = await supabase.from('admin_users').delete().eq('username', username);
    if (error) {
      console.error('Error deleting user:', error);
    } else {
      setDbState(prev => {
        const { [username]: _, ...rest } = prev.users;
        return { ...prev, users: rest };
      });
    }
  };

  const updateSettings = async (data: Partial<Database['settings']>) => {
    const { data: currentSettingsData, error } = await supabase.from('settings').select('*').limit(1).single();
    if (error && error.code !== 'PGRST116') { // Ignore 'not found' error
      console.error('Error fetching settings:', error);
      return;
    }

    const currentSettings = currentSettingsData ? toCamel<Database['settings']>(currentSettingsData) : {};
    const newSettings = { ...currentSettings, ...data };
    await supabaseUpsert('settings', newSettings);

    setDbState(prev => ({
      ...prev,
      settings: { ...prev.settings, ...data }
    }));
  };

  if (!isLoaded) {
    return <div className="min-h-screen flex items-center justify-center bg-stone-100 text-stone-500">載入中...</div>;
  }

  return (
    <AppContext.Provider value={{
      db, setDb, currentView, setCurrentView, currentUser, setCurrentUser,
      fetchMembers, fetchAllMembers, addMember, updateMember, deleteMember, updateMemberCostumeLevel, updateMemberExclusiveWeapon,
      addGuild, updateGuild, deleteGuild,
      addCharacter, updateCharacter, deleteCharacter, updateCharactersOrder,
      addCostume, updateCostume, deleteCostume, updateCostumesOrder,
      updateUserPassword, updateUserRole, addUser, deleteUser, updateSettings,
      restoreData
    }}>
      {children}
    </AppContext.Provider>
  );
};

export const useAppContext = () => {
  const context = useContext(AppContext);
  if (!context) throw new Error('useAppContext must be used within AppProvider');
  return context;
};
